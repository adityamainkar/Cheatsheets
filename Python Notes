(1):
Queue.Queue and collections.deque serve different purposes. 
Queue.Queue is intended for allowing different threads to communicate using queued messages/data, whereas collections.deque is simply intended as a datastructure. 
That's why Queue.Queue has methods like put_nowait(), get_nowait(), and join(), whereas collections.deque doesn't. Queue.Queue isn't intended to be used as a collection, which is why it lacks the likes of the in operator.

It boils down to this: if you have multiple threads and you want them to be able to communicate without the need for locks, 
you're looking for Queue.Queue; if you just want a queue or a double-ended queue as a datastructure, use collections.deque.

Finally, accessing and manipulating the internal deque of a Queue.Queue is playing with fire - you really don't want to be doing that.


(2) When list in initialized: 
arr = [[0]*cols]*rows 
arr[0][0] = 1
Will make all first element of every row gets changed to 1 
Python doesnâ€™t create 5 integer objects but creates only one integer object and 
all the indices of the array arr point to the same int object as shown.


Following is correct way:
arr = [[0 for i in range(cols)] for j in range(rows)] 
arr[0][0] = 1
